<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeForces 546E 网络流好题]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-CodeForces-546E-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%A5%BD%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网络流好题：这里只说题目中未说明的一点，为什么指定有路径的城市可以设置容量为INF？因为他们可以无限往来兵力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* Auther :CaiCai * 网络流拆点题目，网络流已经做了一些题目了，目前小结。如果遇见题目初始化一系列条件，并且问你能否达到某种状态那么大部分是最大流的问题。 * 这道题是一个好题难在建图上面，和一些网络流的题目一样，这道题也需要拆点每座城拆成两个点，然后分别建立源点和束点。 * 因为每一个兵可以自己留在自己的城里，所以a[i][i+N]=INF。自己指向自己的道路可以无限大。 * 因为建图的原因，所以最后存进去调配的兵力就是原来的大小减去网络图中残余的网络量就可以了。如果是0直接输出就完了，证明并没有兵力往来，可能是前面已经没有足够的带宽来进行兵力往来了。 * problem: Codeforces 546E.*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int maxN=205;int m, n;int tot;int temp;int r[maxN&lt;&lt;2][maxN&lt;&lt;2], flow[maxN&lt;&lt;2], pre[maxN&lt;&lt;2], food[maxN], drink[maxN];int sum1 = 0;int sum2 = 0;int bfs(int st,int en)&#123; queue&lt;int&gt; q; memset(pre, -1, sizeof pre); pre[st] = 0; flow[st] = INF; q.push(st); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= tot;i++) &#123; if(pre[i]==-1&amp;&amp;r[u][i]&gt;0) &#123; pre[i] = u; flow[i] = min(r[u][i], flow[u]); q.push(i); &#125; &#125; &#125; return pre[en] == -1 ? -1 : flow[en];&#125;int dfs(int st,int en)&#123; int maxflow=0, icu; while((icu=bfs(st,en))!=-1) &#123; int last = en; int k; while(last!=st) &#123; k = pre[last]; r[k][last] -= icu; r[last][k] += icu; last = k; &#125; maxflow += icu; &#125; return maxflow;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); tot = m * 2 + 1; for (int i = 1; i &lt;= m;i++) &#123; scanf(&quot;%d&quot;, &amp;temp); sum1 += temp; r[0][i] = temp; r[i][i + m] = INF; &#125; for (int i = m+1; i &lt;= 2*m;i++) &#123; scanf(&quot;%d&quot;, &amp;temp); sum2+=temp; r[i][tot] = temp; &#125; for (int i = 0; i &lt; n;i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); r[a][b+m] = INF; r[b][a+m] = INF; &#125; int result; int scr; result = dfs(0, tot); //cout&lt;&lt;result&lt;&lt;endl; if(sum1==result&amp;&amp;sum2==result) &#123; printf(&quot;YES\n&quot;); for (int i = 1; i &lt;= m;i++) &#123; for (int j = 1+m; j &lt;= m*2;j++) &#123; printf(&quot;%d%s&quot;, r[i][j]==0?(0):(INF - r[i][j]), j==2*m?(&quot;&quot;):(&quot; &quot;)); &#125; puts(&quot;&quot;); &#125; &#125; else &#123; printf(&quot;NO\n&quot;); &#125; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2756 二分图问题]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-poj-2756-%E4%BA%8C%E5%88%86%E5%9B%BE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题是一个二分 图的问题，但是博主最近学习了网络流，就用了网络流写了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int INF=50000;const int maxN=205;int N,M; //N个英飞，M个外飞int dis[maxN], r[maxN][maxN], cot=0, tot;int bfs()&#123; memset(dis, -1, sizeof dis); queue&lt;int&gt;q; while(!q.empty()) q.pop(); dis[0] = 1; q.push(0); while(!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= tot;i++) &#123; if(r[u][i]&gt;0&amp;&amp;dis[i]==-1) &#123; dis[i] = dis[u]+1; q.push(i); &#125; &#125; &#125; return dis[tot] &gt; 0 ? 1 : 0;&#125;int dfs(int x,int remain)&#123; if(x==tot) return remain; int k; for (int i = 1; i &lt;= tot;i++) &#123; if (r[x][i] &gt; 0 &amp;&amp; dis[i] == dis[x] + 1&amp;&amp;(k=dfs(i,min(r[x][i],remain)))) &#123; r[x][i] -= k; r[i][x] += k; return k; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;M,&amp;N)) &#123; tot=N+1; memset(r, -1, sizeof(r)); memset(dis, -1, sizeof(dis)); int e1,e2; while (~scanf(&quot;%d%d&quot;,&amp;e1,&amp;e2)) &#123; if(e1==-1&amp;&amp;e2==-1) break; r[e1][e2] = 1; r[e2][e1] = 0; r[0][e1] = 1; r[e2][tot] = 1; &#125; int res=0; int ans = 0; while(bfs()) &#123; res = dfs(0, INF); ans += res; &#125; printf(&quot;%d\n&quot;, ans); for(int i=1; i&lt;=M; i++) &#123; for(int j=M+1; j&lt;tot; j++) &#123; if(r[i][j]==0) printf(&quot;%d %d\n&quot;,i,j); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 1532 网络流入门]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-hdu-1532-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[网络流入门题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define INF 1e9+7#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int maxN=205;int N,M;queue&lt;int&gt;q;int flow[maxN][maxN], dis[maxN];//dis代表的是这个点的层 bool bfs()&#123; memset(dis,-1,sizeof dis); while(!q.empty()) q.pop(); dis[1]=0; q.push(1); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=1;i&lt;=M;i++) &#123; if(flow[u][i]&amp;&amp;dis[i]==-1) &#123; dis[i]=dis[u]+1; q.push(i); &#125; &#125; &#125; return dis[M]!=-1;&#125;int dfs(int x,int remain)&#123; if(x==M||remain==0) return remain; int k; for(int i=1;i&lt;=M;i++)&#123; if(flow[x][i]&gt;0&amp;&amp;dis[i]==dis[x]+1&amp;&amp;(k=dfs(i,min(remain,flow[x][i])))) &#123; flow[x][i]-=k; flow[i][x]+=k; return k; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M)) &#123; memset(flow,0,sizeof flow); for(int i=0;i&lt;N;i++) &#123; int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); flow[a][b]+=c; //这个点坑了我很久后来是看了别人的博客才发现的错误。 &#125; //所以如果这样赋值的话我们有向图的反向边也不能直接赋值为0了。 int ans=0; int res; while(bfs())//dinic开始分层 &#123; while(res=dfs(1,INF)) ans+=res; &#125; printf(&quot;%d\n&quot;,ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2516最小费用最大流]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-POJ-2516%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[提意：M个商店，N个供应商，K种商品，每个供应商向每个商店提供一种商品有他相应的代价，我们需要将这个代价最小化，并且满足各个商店的需求。 题解：建立源点与各个供应商的边，代价边为0，容量边为各个供应商拥有各个商品对应的商品数量。供应商和商店建立代价边为对应的代价，容量边为自己这种商品所拥有的数量，也可以是无限大，商店和汇点建立边，代价边为0，容量边为自己所需要的商品数量。 因为才入门的缘故，博主最开始在纠结为什么所有商品一起跑了，后来才明白每种商品需要一个个的跑，最后每种商品的流x代价相加就是答案。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define pi 3.141592653589793#define e 2.718281828459045#define INF 0x3f3f3f3f#define HalF (l + r)&gt;&gt;1#define lsn rt&lt;&lt;1#define rsn rt&lt;&lt;1|1#define Lson lsn, l, mid#define Rson rsn, mid+1, r#define QL Lson, ql, qr#define QR Rson, ql, qr#define myself rt, l, rusing namespace std;typedef unsigned long long ull;typedef long long ll;const int S = 0;const int maxN = 107;int N, M, K, T, r[maxN][maxN], cost[maxN][maxN];struct node &#123; int thing[maxN];&#125;a[maxN&lt;&lt;1];int pre[maxN], dist[maxN], Flow[maxN]; bool inque[maxN];queue&lt;int&gt; Q;int spfa()&#123; while(!Q.empty()) Q.pop(); memset(pre, -1, sizeof pre); memset(dist, INF, sizeof dist); memset(inque, 0, sizeof inque); memset(Flow, 0, sizeof Flow); Flow[S] = INF; dist[S] = 0; Q.push(S); inque[S] = 1; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); inque[u] = 0; for (int i = 1; i &lt;= T;i++) &#123; if(r[u][i]&amp;&amp;dist[i]&gt;dist[u]+cost[u][i]) &#123; pre[i] = u; dist[i] = cost[u][i] + dist[u]; Flow[i] = min(Flow[u], r[u][i]); if(!inque[i]) &#123; Q.push(i); inque[i] = 1; &#125; &#125; &#125; &#125; return pre[T] != -1;&#125;int main()&#123; while(~scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K),M,N,K) &#123; T = N + M + 1; for (int i = 1; i &lt;= N;i++)&#123; for (int j = 1; j &lt;= K;j++)&#123; scanf(&quot;%d&quot;, &amp;a[i].thing[j]); &#125; &#125; for (int i = 1; i &lt;= M;i++)&#123; for (int j = 1; j &lt;= K;j++)&#123; scanf(&quot;%d&quot;, &amp;a[i + N].thing[j]); &#125; &#125; bool flag = 0; for (int i = 1; i &lt;= K;i++)&#123; int sum1 = 0, sum2 = 0; for (int j = 1; j &lt;= N;j++)&#123; sum1 += a[j].thing[i]; &#125; for (int j = 1; j &lt;= M;j++)&#123; sum2 += a[j + N].thing[i]; &#125; if(sum1&gt;sum2)&#123; flag = 1; break; &#125; &#125; int ans = 0; for (int k = 1; k &lt;= K;k++)&#123; memset(r, 0, sizeof r); memset(cost, INF, sizeof cost); for (int i= 1; i &lt;= N;i++) &#123; r[i][T] = a[i].thing[k]; r[T][i] = 0; cost[i][T] = 0; for (int j = 1; j &lt;= M;j++)&#123; scanf(&quot;%d&quot;, &amp;cost[N + j][i]); cost[i][j + N] = -cost[N + j][i]; r[j+N][i]=a[j+N].thing[k]; r[S][j + N] = a[j + N].thing[k]; &#125; &#125; if(flag) continue; for (int i = 1; i &lt;= M;i++)&#123; r[S][i + N] = a[i + N].thing[k]; cost[S][i + N] = 0; &#125; while(spfa()) &#123; int now = T; int last; while(now) &#123; last = pre[now]; r[last][now] -= Flow[T]; r[now][last] += Flow[T]; now = last; &#125; ans += dist[T] * Flow[T]; &#125; &#125; printf(&quot;%d\n&quot;,flag==1?-1:ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 3549 网络流Dinic板子题]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-hdu-3549-%E7%BD%91%E7%BB%9C%E6%B5%81Dinic%E6%9D%BF%E5%AD%90%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网络流Dinic板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define INF 1e9+7#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int maxN=1005;int N,M;int r[maxN][maxN], pre[maxN], flow[maxN][maxN];int dis[maxN];queue&lt;int&gt; q;int bfs()&#123; while(!q.empty()) q.pop(); memset(dis, -1, sizeof dis); dis[1] = 0; q.push(1); while(!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= N;i++) &#123; if(flow[u][i]&gt;0&amp;&amp;dis[i]==-1) &#123; dis[i] = dis[u] + 1; q.push(i); &#125; &#125; &#125; return dis[N] != -1;&#125;int dfs(int x,int remain)&#123; if(remain==0||x==N) return remain; int k; for (int i = 1; i &lt;= N;i++) &#123; if(flow[x][i]&gt;0&amp;&amp;dis[i]==dis[x]+1&amp;&amp;(k=dfs(i,min(remain,flow[x][i])))) &#123; flow[x][i] -= k; flow[i][x] += k; return k; &#125; &#125; return 0;&#125;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); int cnt=1; while(t--) &#123; memset(flow, 0, sizeof flow); scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 0; i &lt; M;i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); flow[a][b] += c; &#125; int ans = 0; int res; while(bfs()) &#123; while(res=dfs(1,INF)) ans += res; &#125; printf(&quot;Case %d: %d\n&quot;,cnt++, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 2063 过山车]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-hdu-2063-%E8%BF%87%E5%B1%B1%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[二分图问题用网络流跑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* problem: HDU2063 * Auther:CaiCai * 第二次用EK跑二分图，没什么好说的，建好图就一定可以做 * 建图就是女生一边，男生一边，再把源点和束点找到，权值分别是1这样就可以把图建完了。*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int maxN=505;int m, n;int temp;int r[maxN&lt;&lt;1][maxN&lt;&lt;1], flow[maxN&lt;&lt;1], pre[maxN&lt;&lt;1];int sum1 = 0;int sum2 = 0;int K, M, N;int tot;int bfs(int st,int en)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); memset(pre, -1, sizeof pre); pre[0] = 0; flow[0]=INF; q.push(0); while(!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= tot;i++) &#123; if(r[u][i]&gt;0&amp;&amp;pre[i]==-1) &#123; pre[i] = u; flow[i] = min(flow[u], r[u][i]); q.push(i); &#125; &#125; &#125; return pre[en] == -1 ? -1 : flow[en];&#125;int maxflow(int st,int en)&#123; int icr = 0; int ans = 0; while((icr=bfs(st,en))!=-1) &#123; int k = en; while(k!=st) &#123; int last = pre[k]; r[last][k] -= icr; r[k][last] += icr; k = last; &#125; ans += icr; &#125; return ans;&#125;int main()&#123; while (~scanf(&quot;%d&quot;,&amp;K)) &#123; if(K==0) break; scanf(&quot;%d%d&quot;,&amp;M,&amp;N); memset(r, 0, sizeof r); tot = M + N+1; for (int i = 1; i &lt;= M;i++) r[0][i] = 1; for (int i = M + 1; i &lt;= M + N;i++) r[i][tot] = 1; for (int i = 0; i &lt; K; i++) &#123; int a, b; scanf(&quot;%d&quot;, &amp;a); scanf(&quot;%d&quot;, &amp;b); r[a][b + M] = 1; &#125; int ans = maxflow(0, tot); printf(&quot;%d\n&quot;, ans); &#125; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流入门裸题]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8%E8%A3%B8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网络流板子题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int MAXM = 6000011;const int MAXN = 1000011;int inf;int n,m;int first[MAXN];int ecnt;int s,t;int dis[MAXN];int ans;struct edge&#123; int v,f; int next; &#125;e[MAXM];inline int getint()&#123; int w=0,q=0; char c=getchar(); while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;&amp;&amp;c!=&apos;-&apos;) c=getchar(); if(c==&apos;-&apos;) q=1,c=getchar(); while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) w=w*10+c-&apos;0&apos;,c=getchar(); return q?-w:w; &#125;inline bool link(int x,int y,int z)&#123; e[++ecnt].next=first[x];first[x]=ecnt;e[ecnt].v=y;e[ecnt].f=z; e[++ecnt].next=first[y];first[y]=ecnt;e[ecnt].v=x;e[ecnt].f=z; &#125;inline bool bfs()&#123; memset(dis,127/3,sizeof dis); int ceng=dis[t]; queue&lt;int&gt;q; while(!q.empty()) q.pop(); dis[1]=1;q.push(1);//dis存层; while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=first[u];i;i=e[i].next) &#123; if(e[i].f&amp;&amp;dis[e[i].v]==ceng) &#123; dis[e[i].v]=dis[u]+1; q.push(e[i].v); &#125; &#125; if(dis[t]!=ceng) return 1; &#125; return 0; &#125;inline int maxflow(int now,int remain)&#123; if(remain==0||now==t) return remain; int flow=0; for(int i=first[now];i;i=e[i].next) &#123; if(dis[e[i].v]==dis[now]+1&amp;&amp;e[i].f) &#123; int f=maxflow(e[i].v,min(remain,e[i].f)); if(f) &#123; e[i].f-=f;e[i^1].f+=f; flow+=f ; remain-=f; if(remain==0) return flow; &#125; else dis[e[i].v]=-1; &#125; &#125; return flow;&#125;inline void solve()&#123; s=1,t=n*m;inf=1&lt;&lt;30; while(bfs()) &#123; ans+=maxflow(s,inf); &#125; printf(&quot;%d&quot;,ans);&#125;int main()&#123; n=getint(); m=getint(); int x; ecnt=1; int nowx,nownex; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++)&#123; nowx=(i-1)*m+j,nownex=nowx+1; x=getint(); link(nowx,nownex,x); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) &#123; nowx=(i-1)*m+j,nownex=nowx+m; x=getint(); link(nowx,nownex,x); &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) &#123; nowx=(i-1)*m+j,nownex=nowx+m+1; x=getint(); link(nowx,nownex,x); &#125; solve(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3974 dfs序建树+线段树区间修改]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27-HDU3974-dfs%E5%BA%8F%E5%BB%BA%E6%A0%91%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[HDU3974线段树+dfs序建树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include&lt;vector&gt;using namespace std;const int siz = 1e5 + 5;int id = 1;vector&lt;int&gt; G[siz];int ll[siz],rr[siz],vis[siz];struct tree&#123; int l, r; int date;&#125; tree[siz &lt;&lt; 2];void pushDown(int i)&#123; if(tree[i].date==-1) return ; tree[i &lt;&lt; 1].date = tree[i].date; tree[i &lt;&lt; 1 | 1].date=tree[i].date; tree[i].date = -1;&#125;void build_tree(int i,int l,int r)&#123; tree[i].l = l; tree[i].r = r; tree[i].date = -1; int mid = l + r &gt;&gt; 1; if(l==r) return; build_tree(i &lt;&lt; 1, l, mid); build_tree(i &lt;&lt; 1 | 1, mid + 1, r);&#125;void Change(int i,int L,int R,int p)&#123; if(L&lt;=tree[i].l&amp;&amp;tree[i].r&lt;=R)&#123; tree[i].date=p; return; &#125; pushDown(i); int m=(tree[i].l+tree[i].r)&gt;&gt;1; if(L&lt;=m) Change(i&lt;&lt;1,L,R,p); if(R&gt;m) Change(i&lt;&lt;1|1,L,R,p);&#125; int query(int i,int index)&#123; if(tree[i].l==tree[i].r) return tree[i].date; pushDown(i); int m=(tree[i].l+tree[i].r)&gt;&gt;1; if(index&lt;=m) query(i&lt;&lt;1,index); else query(i&lt;&lt;1|1,index);&#125;void dfs(int s)&#123; int i,tmp; ll[s]=id++; for(i=0;i&lt;G[s].size();i++)&#123; tmp=G[s][i]; dfs(tmp); &#125; rr[s]=id++;&#125;int main()&#123; char ch; int t,n,m,u,v,i,cas=1; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); build_tree(1,1,2*n); for(i=1;i&lt;=n;i++) vis[i]=0,G[i].clear(); for(i=1;i&lt;n;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); G[v].push_back(u); vis[u]=1; &#125; memset(ll,-1,sizeof(ll)); memset(rr,-1,sizeof(rr)); id=1; for(i=1;i&lt;=n;i++) if(vis[i]==0) dfs(i); scanf(&quot;%d&quot;,&amp;m); printf(&quot;Case #%d:\n&quot;,cas++); while(m--)&#123; cin&gt;&gt;ch; if(ch==&apos;C&apos;)&#123; scanf(&quot;%d&quot;,&amp;u); printf(&quot;%d\n&quot;,query(1,ll[u])); &#125; else&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); Change(1,ll[u],rr[u],v); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3281 拆点]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27-poj-3281-%E6%8B%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[网络流最大流问题： 很好的一道题，注释讲的很清楚，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* Auther :CaiCai * poj 3281 网络流建图好题。 * 网络流入门，开始建图难在我们的源点和终点的建立，在接触几道网络流的题后大概有了一点建图概念。 * 这道题的建图难在拆点，如果不拆点跑出来的最大流应该是2，因为一头牛的流量承受了食物和饮料。（博主拙见）。 * 精髓就在这里，牛拆点，确保一头牛就选一套food和drink的搭配 * 加个源点和汇点。源点与食物、饮料和汇点的边容量都是1，表示每种食物和饮料只有一个。*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;limits&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#define lowbit(x) ( x&amp;(-x) )#define pi 3.141592653589793#define e 2.718281828459045using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int maxN=205;int n, f, d;int tot;int r[maxN&lt;&lt;2][maxN&lt;&lt;2], flow[maxN&lt;&lt;2], pre[maxN&lt;&lt;2], food[maxN], drink[maxN];void init()&#123; memset(r, 0, sizeof r); tot = n * 2 + d + f + 1; return ;&#125;int bfs(int st,int en)&#123; memset(pre, -1, sizeof pre); queue&lt;int&gt; q; while(!q.empty()) q.pop(); pre[st] = 0; flow[st]=INF; q.push(st); while(!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= tot;i++) &#123; if(r[u][i]&gt;0&amp;&amp;pre[i]==-1) &#123; flow[i] = min(r[u][i], flow[u]); q.push(i); pre[i] = u; &#125; &#125; &#125; return pre[en] == -1 ? -1 : flow[en];&#125;int dfs(int st,int en)&#123; int k; int flowmax = 0; while((k=bfs(st, en))!=-1) &#123; int par = en, last; while(par!=st) &#123; last = pre[par]; r[last][par] -= k; r[par][last] += k; par = last; &#125; flowmax += k; &#125; return flowmax;&#125;int main()&#123; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;f,&amp;d)) &#123; init(); int F=0,D=0; for (int i = 1; i &lt;= n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;F,&amp;D); for (int j = 1; j &lt;= F;j++) &#123; scanf(&quot;%d&quot;, &amp;food[j]); r[0][food[j]] = 1; r[food[j]][f + i * 2 - 1] = 1; &#125; for (int j = 1; j &lt;= D;j++) &#123; scanf(&quot;%d&quot;, &amp;drink[j]); r[f + i * 2][f + 2 * n + drink[j]] = 1; r[f + 2 * n + drink[j]][tot] = 1; &#125; r[f + i * 2 - 1][f + i * 2] = 1; &#125; printf(&quot;%d\n&quot;, dfs(0, tot)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2528 线段树离散化处理]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27-poj2528-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A6%BB%E6%95%A3%E5%8C%96%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[直接存肯定会炸所以我们离散化处理，离散化在我的看法就是将距离大的缩小距离来节省空间。 ps:左右儿子每次手打真的容易粗心错，小编在这里建议用宏定义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;queue&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define lson i&lt;&lt;1#define rson i&lt;&lt;1|1using namespace std;const int manx = 20000 + 5;const int MANX =1e7+10;typedef long long ll;ll posi1[manx &lt;&lt; 1], posi2[manx &lt;&lt; 1];set&lt;ll&gt; st;ll id[MANX ];ll vis[manx&lt;&lt;1];struct tree&#123; ll l,r; int rang;&#125;tree[manx&lt;&lt;2];void pushDown(ll i)&#123; if(tree[i].rang) &#123; tree[lson].rang=tree[rson].rang=tree[i].rang; tree[i].rang=0; &#125; return ;&#125;void build_tree(ll i,ll l,ll r)&#123; //cout&lt;&lt;i&lt;&lt;endl; tree[i].l=l; tree[i].r=r; tree[i].rang=0; if(l==r) return ; int mid=l+r&gt;&gt;1; build_tree(lson,l,mid); build_tree(rson,mid+1,r);&#125;void change(ll i,ll l,ll r,ll c)&#123; //cout&lt;&lt;c&lt;&lt;endl; if(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r) &#123; tree[i].rang=c; return ; &#125; pushDown(i); int mid=tree[i].l+tree[i].r&gt;&gt;1; if(l&lt;=mid ) change(lson,l,r,c); if(r&gt;mid) change(rson,l,r,c);&#125;ll query(ll i)&#123; //cout&lt;&lt;tree[i].rang&lt;&lt;&apos; &apos;&lt;&lt;tree[i].l&lt;&lt;&apos; &apos;&lt;&lt;tree[i].r&lt;&lt;endl; if(tree[i].rang) &#123; ll x=tree[i].rang; if(!vis[x]) &#123; vis[x]=1; return 1; &#125; return 0; &#125; pushDown(i); if(tree[i].l==tree[i].r) return 0; return query(lson)+query(rson);&#125;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); while(t--)&#123; ll q; memset(vis,0,sizeof vis); st.clear(); scanf(&quot;%lld&quot;, &amp;q); for (int i = 1; i &lt;=q;i++) &#123; scanf(&quot;%lld%lld&quot;, &amp;posi1[i], &amp;posi2[i]); st.insert(posi1[i]); st.insert(posi2[i]); &#125; ll cnt=1; for(set&lt;ll&gt;::iterator it=st.begin();it!=st.end();it++) &#123; id[*it]=cnt++; &#125; build_tree(1,1,cnt); for(int i=1;i&lt;=q;i++) &#123; change(1,id[posi1[i]],id[posi2[i]],i); &#125; printf(&quot;%lld\n&quot;,query(1)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1540区间合并]]></title>
    <url>%2F2019%2F07%2F26%2F2019-07-26-1540%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;using namespace std; const int maxn = 50000+10; int n,m;int s[maxn],top;//s为模拟栈 struct node&#123; int l,r; int ls,rs,ms;//ls,左端最大连续区间，rs右端最大连续区间，ms区间内最大连续区间&#125; a[maxn&lt;&lt;2]; void init(int l,int r,int i)&#123; a[i].l = l; a[i].r = r; a[i].ls = a[i].rs = a[i].ms = r-l+1; if(l!=r) &#123; int mid = (l+r)&gt;&gt;1; init(l,mid,i*2); init(mid+1,r,2*i+1); &#125;&#125; void insert(int i,int t,int x)&#123; if(a[i].l == a[i].r) &#123; if(x==1) a[i].ls = a[i].rs = a[i].ms = 1;//修复 else a[i].ls = a[i].rs = a[i].ms = 0;//破坏 return ; &#125; int mid = (a[i].l+a[i].r)&gt;&gt;1; if(t&lt;=mid) insert(2*i,t,x); else insert(2*i+1,t,x); a[i].ls = a[2*i].ls;//左区间 a[i].rs = a[2*i+1].rs;//右区间 a[i].ms = max(max(a[2*i].ms,a[2*i+1].ms),a[2*i].rs+a[2*i+1].ls);//父亲区间内的最大区间必定是，左子树最大区间，右子树最大区间，左右子树合并的中间区间，三者中最大的区间值 if(a[2*i].ls == a[2*i].r-a[2*i].l+1)//左子树区间满了的话，父亲左区间要加上右孩子的左区间 a[i].ls += a[2*i+1].ls; if(a[2*i+1].rs == a[2*i+1].r-a[2*i+1].l+1)//同理 a[i].rs += a[2*i].rs;&#125; int query(int i,int t)&#123; if(a[i].l == a[i].r || a[i].ms == 0 || a[i].ms == a[i].r-a[i].l+1)//到了叶子节点或者该访问区间为空或者已满都不必要往下走了 return a[i].ms; int mid = (a[i].l+a[i].r)&gt;&gt;1; if(t&lt;=mid) &#123; if(t&gt;=a[2*i].r-a[2*i].rs+1)//因为t&lt;=mid，看左子树，a[2*i].r-a[2*i].rs+1代表左子树右边连续区间的左边界值，如果t在左子树的右区间内，则要看右子树的左区间有多长并返回 return query(2*i,t)+query(2*i+1,mid+1); else return query(2*i,t);//如果不在左子树的右边界区间内，则只需要看左子树 &#125; else &#123; if(t&lt;=a[2*i+1].l+a[2*i+1].ls-1)//同理 return query(2*i+1,t)+query(2*i,mid); else return query(2*i+1,t); &#125;&#125; int main()&#123; int i,j,x; char ch[2]; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; top = 0; init(1,n,1); while(m--) &#123; scanf(&quot;%s&quot;,ch); if(ch[0] == &apos;D&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); s[top++] = x; insert(1,x,0); &#125; else if(ch[0] == &apos;Q&apos;) &#123; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\n&quot;,query(1,x)); &#125; else &#123; if(x&gt;0) &#123; x = s[--top]; insert(1,x,1); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1698]]></title>
    <url>%2F2019%2F07%2F23%2F2019-07-23-HDU-1698%2F</url>
    <content type="text"><![CDATA[线段树区间修改模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int manx=100005;struct tree&#123; int l,r; int lazy; long long sum; &#125;tree[manx&lt;&lt;2];void pushUp(int i)&#123; tree[i].sum=tree[i&lt;&lt;1].sum+tree[i&lt;&lt;1|1].sum;&#125;void build_tree(int i,int l,int r)&#123; tree[i].l=l; tree[i].r=r; tree[i].lazy=0; if(l==r) &#123; tree[i].sum=1; return ; &#125; int mid=(l+r)&gt;&gt;1; build_tree(i&lt;&lt;1,l,mid); build_tree(i&lt;&lt;1|1,mid+1,r); pushUp(i);&#125;void pushDown(int i)&#123; if(tree[i].lazy) &#123; tree[i&lt;&lt;1].lazy=tree[i&lt;&lt;1|1].lazy=tree[i].lazy; int mid=(tree[i].l+tree[i].r)&gt;&gt;1; tree[i&lt;&lt;1].sum=(mid-tree[i].l+1)*tree[i].lazy; tree[i&lt;&lt;1|1].sum=(tree[i].r-mid)*tree[i].lazy; tree[i].lazy=0; &#125;&#125;void upDate(int i,int l,int r,int c)&#123; if(tree[i].l==l&amp;&amp;tree[i].r==r) &#123; tree[i].lazy=c; tree[i].sum=(tree[i].r-tree[i].l+1)*c; return ; &#125; pushDown(i); int mid=(tree[i].l+tree[i].r)&gt;&gt;1; if(r&lt;=mid) upDate(i&lt;&lt;1,l,r,c); else if(l&gt;mid) upDate(i&lt;&lt;1|1,l,r,c); else &#123; upDate(i&lt;&lt;1,l,mid,c); upDate(i&lt;&lt;1|1,mid+1,r,c); &#125; pushUp(i);&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); int cnt=0; while(t--)&#123; cnt++; int n,q; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); build_tree(1,1,n); while(q--)&#123; int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); upDate(1,x,y,z); &#125; printf(&quot;Case %d: The total value of the hook is %d.\n&quot;,cnt,tree[1].sum); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3468]]></title>
    <url>%2F2019%2F07%2F23%2F2019-07-23-poj-3468%2F</url>
    <content type="text"><![CDATA[线段树区间求和+区间修改板子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define ll long long#define lson l, mid, rt &lt;&lt; 1#define rson mid + 1, r, rt &lt;&lt; 1 | 1using namespace std;const int MAXN = 1e5 + 10;struct tree&#123; int l,r; long long sum; long long Icm;&#125;tree[MAXN&lt;&lt;2];void push_up(int rt)&#123;//向上更新 tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum;&#125;void push_down(int rt, int m)&#123; if(tree[rt].Icm)&#123;//若有标记,则将标记向下移动一层 tree[rt &lt;&lt; 1].Icm += tree[rt].Icm; tree[rt &lt;&lt; 1 | 1].Icm += tree[rt].Icm; tree[rt &lt;&lt; 1].sum += (m - (m &gt;&gt; 1)) * tree[rt].Icm; tree[rt &lt;&lt; 1 | 1].sum += (m &gt;&gt; 1) * tree[rt].Icm; tree[rt].Icm = 0;//取消本层标记 &#125;&#125;void build(int l, int r, int rt)&#123;//建树 //cout&lt;&lt;rt&lt;&lt;endl; tree[rt].l=l; tree[rt].r=r; tree[rt].Icm = 0; if(l == r)&#123; scanf(&quot;%lld&quot;, &amp;tree[rt].sum); return; &#125; int mid = (l + r) &gt;&gt; 1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); push_up(rt);//向上更新&#125;void update(int L, int R, ll key,int rt)&#123;//区间更新 if(L == tree[rt].l &amp;&amp; R == tree[rt].r)&#123; tree[rt].sum += (tree[rt].r - tree[rt].l + 1) * key; tree[rt].Icm += key; return; &#125; push_down(rt, tree[rt].r - tree[rt].l + 1);//向下更新 int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; if(R &lt;= mid) update(L, R, key,rt&lt;&lt;1); else if(L &gt; mid) update(L, R, key,rt&lt;&lt;1|1); else &#123; update(L,mid,key,rt&lt;&lt;1); update(mid+1,R,key,rt&lt;&lt;1|1); &#125; push_up(rt);//向上更新&#125;ll query(int L, int R, int rt)&#123;//区间求和 //cout&lt;&lt;rt&lt;&lt;&apos; &apos;&lt;&lt;tree[rt].l&lt;&lt;&apos; &apos;&lt;&lt;tree[rt].r&lt;&lt;endl;; if(L == tree[rt].l &amp;&amp; tree[rt].r == R) return tree[rt].sum; push_down(rt, tree[rt].r - tree[rt].l + 1);//向下更新 int mid = (tree[rt].l + tree[rt].r) &gt;&gt; 1; ll ans = 0; if(R &lt;= mid) ans += query(L, R, rt&lt;&lt;1); else if(L &gt; mid) ans += query(L, R, rt&lt;&lt;1|1); else &#123; ans+=query(L,mid,rt&lt;&lt;1)+query(mid+1,R,rt&lt;&lt;1|1); &#125; return ans;&#125;int main(void)&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); build(1, n, 1); while(m--)&#123; char str[3]; int x, y; ll z; scanf(&quot;%s&quot;, str); if(str[0] == &apos;C&apos;)&#123; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;z); update(x, y, z, 1); &#125;else&#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, query(x, y, 1)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[574 Div2 A]]></title>
    <url>%2F2019%2F07%2F19%2F2019-07-19-574-Div2-A%2F</url>
    <content type="text"><![CDATA[A. Drinks Choosing time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Old timers of Summer Informatics School can remember previous camps in which each student was given a drink of his choice on the vechorka (late-evening meal). Or may be the story was more complicated? There are nn students living in a building, and for each of them the favorite drink aiai is known. So you know nn integers a1,a2,…,ana1,a2,…,an, where aiai (1≤ai≤k1≤ai≤k) is the type of the favorite drink of the ii-th student. The drink types are numbered from 11 to kk. There are infinite number of drink sets. Each set consists of exactly two portions of the same drink. In other words, there are kk types of drink sets, the jj-th type contains two portions of the drink jj. The available number of sets of each of the kk types is infinite. You know that students will receive the minimum possible number of sets to give all students exactly one drink. Obviously, the number of sets will be exactly ⌈n2⌉⌈n2⌉, where ⌈x⌉⌈x⌉ is xx rounded up. After students receive the sets, they will distribute their portions by their choice: each student will get exactly one portion. Note, that if nn is odd then one portion will remain unused and the students’ teacher will drink it. What is the maximum number of students that can get their favorite drink if ⌈n2⌉⌈n2⌉ sets will be chosen optimally and students will distribute portions between themselves optimally? Input The first line of the input contains two integers nn and kk (1≤n,k≤10001≤n,k≤1000) — the number of students in the building and the number of different drinks. The next nn lines contain student’s favorite drinks. The ii-th line contains a single integer from 11 to kk — the type of the favorite drink of the ii-th student. Output Print exactly one integer — the maximum number of students that can get a favorite drink. 常规思维题没什么好说的。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int arr[1005];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; int temp; cin&gt;&gt;temp; arr[temp]++; &#125; int ji=0; for(int i=1;i&lt;=m;i++) if(arr[i]&amp;1)ji++; if(n&amp;1)ji--; cout&lt;&lt;n-ji/2&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[573 Div2 D]]></title>
    <url>%2F2019%2F07%2F15%2F2019-07-15-573-Div2-D%2F</url>
    <content type="text"><![CDATA[分析：1、若有类似“2 3 3 ”则后手胜，因为有这个序列就必须在这个序列中去石子（因为如果在这个序列以外取子，则会导致输的后者情况），但在这个序列中取不到可解情况，所以该状态为必败态； 2、若序列中有俩对相同的石子，则后手胜； 3、除1、2情况外就把利用sum+起来，每个加就+a[i]-i 为了把他提到前面他不能再动的最优状态（因为俩者都采取最优策略！！！） 第三种状态还没清楚暂时挂这里过后解决 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define INF 0x3f3f3f3f#define ll long long#include &lt;algorithm&gt;using namespace std;const int manx=100005;ll n, s[110000], cnt, s2c;bool tl;long long arr[manx];int main() &#123; cin.tie(0); ios::sync_with_stdio(false); for(int i=0;i&lt;110000;i++) s[i]=INF; //REP(i, 110000)s[i] = MINF; cin &gt;&gt; n; if (n == 1) &#123; ll a; cin &gt;&gt; a; cout &lt;&lt; (a % 2 == 0 ? &quot;cslnb&quot; : &quot;sjfnb&quot;) &lt;&lt; endl; return 0; &#125; //REP(i, n)cin &gt;&gt; s[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; sort(s, s + n); //REP(i, n) &#123; for(int i=0;i&lt;n;i++) &#123; cnt += s[i] - i; if (s[i] == s[i + 1])s2c++; if (s[i] == 0 &amp;&amp; s[i + 1] == 0)tl = true; if (s[i] + 1 == s[i + 1] &amp;&amp; s[i + 1] == s[i + 2])tl = true; &#125; if (s2c &gt;= 2)tl = true; if (cnt % 2 == 0)tl = true; cout &lt;&lt; (tl ? &quot;cslnb&quot; : &quot;sjfnb&quot;) &lt;&lt; endl; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[572 Div2 B]]></title>
    <url>%2F2019%2F07%2F13%2F2019-06-26-572-Div2-B%2F</url>
    <content type="text"><![CDATA[B. Number Circle time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output You are given nn numbers a1,a2,…,ana1,a2,…,an. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors? For example, for the array [1,4,5,6,7,8][1,4,5,6,7,8], the arrangement on the left is valid, while arrangement on the right is not, as 5≥4+15≥4+1 and 8&gt;1+68&gt;1+6. Input The first line contains a single integer nn (3≤n≤1053≤n≤105) — the number of numbers. The second line contains nn integers a1,a2,…,ana1,a2,…,an (1≤ai≤1091≤ai≤109) — the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed). Output If there is no solution, output “NO” in the first line. If there is a solution, output “YES” in the first line. In the second line output nn numbers — elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element. 思路：先排序，如果最大的比第二第三的和还要大，则不可能有方案，否则可以先把最大的放在第一个第二大的放在第二个，第三大的放在最后一个，最后中间以此填补。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int arr[100005];int brr[100005];int cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;arr[i]; &#125; sort(arr+1,arr+1+n,cmp); if(arr[1]&gt;=arr[2]+arr[3]) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else &#123; brr[1]=arr[1]; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(int i=2,j=2,k=n;j&lt;=k;) &#123; //cout&lt;&lt;i&lt;&lt;endl; brr[j++]=arr[i++]; if(j&lt;=k)brr[k--]=arr[i++]; &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;brr[i]&lt;&lt;&apos; &apos;; cout&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[573 Div2 C]]></title>
    <url>%2F2019%2F07%2F13%2F2019-07-13-573-Div2-C%2F</url>
    <content type="text"><![CDATA[C. Tokitsukaze and Discard Items time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Recently, Tokitsukaze found an interesting game. Tokitsukaze had nn items at the beginning of this game. However, she thought there were too many items, so now she wants to discard mm (1≤m≤n1≤m≤n) special items of them. These nn items are marked with indices from 11 to nn. In the beginning, the item with index ii is placed on the ii-th position. Items are divided into several pages orderly, such that each page contains exactly kk positions and the last positions on the last page may be left empty. Tokitsukaze would do the following operation: focus on the first special page that contains at least one special item, and at one time, Tokitsukaze would discard all special items on this page. After an item is discarded or moved, its old position would be empty, and then the item below it, if exists, would move up to this empty position. The movement may bring many items forward and even into previous pages, so Tokitsukaze would keep waiting until all the items stop moving, and then do the operation (i.e. check the special page and discard the special items) repeatedly until there is no item need to be discarded. Consider the first example from the statement: n=10n=10, m=4m=4, k=5k=5, p=[3,5,7,10]p=[3,5,7,10]. The are two pages. Initially, the first page is special (since it is the first page containing a special item). So Tokitsukaze discards the special items with indices 33 and 55. After, the first page remains to be special. It contains [1,2,4,6,7][1,2,4,6,7], Tokitsukaze discards the special item with index 77. After, the second page is special (since it is the first page containing a special item). It contains [9,10][9,10], Tokitsukaze discards the special item with index 1010. Tokitsukaze wants to know the number of operations she would do in total. Input The first line contains three integers nn, mm and kk (1≤n≤10181≤n≤1018, 1≤m≤1051≤m≤105, 1≤m,k≤n1≤m,k≤n) — the number of items, the number of special items to be discarded and the number of positions in each page. The second line contains mm distinct integers p1,p2,…,pmp1,p2,…,pm (1≤p1&lt;p2&lt;…&lt;pm≤n1≤p1&lt;p2&lt;…&lt;pm≤n) — the indices of special items which should be discarded. 思路：模拟题，直接按题意模拟就好了，每次找出需要动的第一页上的所有数，再将记录移动的计数器增加，重新找下一页， 注意找的时候位置要减去移动的计数器move。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int manx=100005;long long arr[manx];int main()&#123; long long m,n,k; cin&gt;&gt;m&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;arr[i]; &#125; long long move=0; long long i=1,j=1; long ans=0; while(i&lt;=n) &#123; j=i; long long tag=(arr[i]-move-1)/k;//减1的目的是为了保证边缘也在这一页，比如k=5，如果不-1则5在下一页 while(((arr[j]-move-1)/k==tag)&amp;&amp;j&lt;=m)//找这一页第一个要删除的位置，并且和这个同一页的所有特殊数全部删掉。 j++; move+=j-i; ans++; i=j; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[572 Div2 C]]></title>
    <url>%2F2019%2F07%2F13%2F2019-06-26-572-Div2-C%2F</url>
    <content type="text"><![CDATA[C. Candies! time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Consider a sequence of digits of length 2k2k [a1,a2,…,a2k][a1,a2,…,a2k]. We perform the following operation with it: replace pairs (a2i+1,a2i+2)(a2i+1,a2i+2) with (a2i+1+a2i+2)mod10(a2i+1+a2i+2)mod10 for 0≤i&lt;2k−10≤i&lt;2k−1. For every ii where a2i+1+a2i+2≥10a2i+1+a2i+2≥10 we get a candy! As a result, we will get a sequence of length 2k−12k−1. Less formally, we partition sequence of length 2k2k into 2k−12k−1 pairs, each consisting of 2 numbers: the first pair consists of the first and second numbers, the second of the third and fourth ……, the last pair consists of the (2k−12k−1)-th and (2k2k)-th numbers. For every pair such that sum of numbers in it is at least 1010, we get a candy. After that, we replace every pair of numbers with a remainder of the division of their sum by 1010 (and don’t change the order of the numbers). Perform this operation with a resulting array until it becomes of length 11. Let f([a1,a2,…,a2k])f([a1,a2,…,a2k]) denote the number of candies we get in this process. For example: if the starting sequence is [8,7,3,1,7,0,9,4][8,7,3,1,7,0,9,4] then: After the first operation the sequence becomes [(8+7)mod10,(3+1)mod10,(7+0)mod10,(9+4)mod10][(8+7)mod10,(3+1)mod10,(7+0)mod10,(9+4)mod10] == [5,4,7,3][5,4,7,3], and we get 22 candies as 8+7≥108+7≥10 and 9+4≥109+4≥10. After the second operation the sequence becomes [(5+4)mod10,(7+3)mod10][(5+4)mod10,(7+3)mod10] == [9,0][9,0], and we get one more candy as 7+3≥107+3≥10. After the final operation sequence becomes [(9+0)mod10][(9+0)mod10] == [9][9]. Therefore, f([8,7,3,1,7,0,9,4])=3f([8,7,3,1,7,0,9,4])=3 as we got 33 candies in total. You are given a sequence of digits of length nn s1,s2,…sns1,s2,…sn. You have to answer qq queries of the form (li,ri)(li,ri), where for ii-th query you have to output f([sli,sli+1,…,sri])f([sli,sli+1,…,sri]). It is guaranteed that ri−li+1ri−li+1 is of form 2k2k for some nonnegative integer kk. Input The first line contains a single integer nn (1≤n≤1051≤n≤105) — the length of the sequence. The second line contains nn digits s1,s2,…,sns1,s2,…,sn (0≤si≤90≤si≤9). The third line contains a single integer qq (1≤q≤1051≤q≤105) — the number of queries. Each of the next qq lines contains two integers lili, riri (1≤li≤ri≤n1≤li≤ri≤n) — ii-th query. It is guaranteed that ri−li+1ri−li+1 is a nonnegative integer power of 22. Output Output qq lines, in ii-th line output single integer — f([sli,sli+1,…,sri])f([sli,sli+1,…,sri]), answer to the ii-th query.Examples input Copy 12345688 7 3 1 7 0 9 431 82 57 7 output Copy 123310 input Copy 12345660 1 2 3 3 531 21 43 6 output Copy 123001 Note The first example illustrates an example from the statement. f([7,3,1,7])=1f([7,3,1,7])=1: sequence of operations is [7,3,1,7]→[(7+3)mod10,(1+7)mod10][7,3,1,7]→[(7+3)mod10,(1+7)mod10] == [0,8][0,8] and one candy as 7+3≥107+3≥10 →→ [(0+8)mod10][(0+8)mod10] == [8][8], so we get only 11 candy. f([9])=0f([9])=0 as we don’t perform operations with it. 我的思路是直接除以10就完了 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int arr[100005];long sum[100005];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;arr[i]; sum[i]=sum[i-1]+arr[i]; &#125; int temp; cin&gt;&gt;temp; while(temp--) &#123; int a,b,ans; cin&gt;&gt;a&gt;&gt;b; if(a!=b) ans=sum[b]-sum[a-1]; else ans=arr[a]; //cout&lt;&lt;ans&lt;&lt;endl; cout&lt;&lt;ans/10&lt;&lt;endl; &#125;&#125; 附上大佬DP代码后面研究 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define N 500500using namespace std;int n,m,l,r,lg[N],mi[20],a[N],f[N][20],g[N][20];int main()&#123; //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n); lg[1]=0;mi[0]=1; for(int i=1;(1&lt;&lt;(i-1))&lt;=n;i++)&#123; lg[1&lt;&lt;i]=i; mi[i]=1&lt;&lt;i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); g[i][0]=a[i]; &#125; for(int j=1;mi[j]&lt;=n;j++) for(int i=1;i+mi[j]-1&lt;=n;i++)&#123; f[i][j]=f[i][j-1]+f[i+mi[j-1]][j-1]+(g[i][j-1]+g[i+mi[j-1]][j-1]&gt;=10); g[i][j]=(g[i][j-1]+g[i+mi[j-1]][j-1])%10; &#125; scanf(&quot;%d&quot;,&amp;m); while(m--)&#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\n&quot;,f[l][lg[r-l+1]]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2588 - GCD（欧拉函数）]]></title>
    <url>%2F2019%2F07%2F10%2F2019-07-10-HDU-2588---GCD%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[GCDTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 3358 Accepted Submission(s): 1802 Problem Description The greatest common divisor GCD(a,b) of two positive integers a and b,sometimes written (a,b),is the largest divisor common to a and b,For example,(1,2)=1,(12,18)=6.(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)&gt;=M. Input The first line of input is an integer T(T&lt;=100) representing the number of test cases. The following T lines each contains two numbers N and M (2&lt;=N&lt;=1000000000, 1&lt;=M&lt;=N), representing a test case. Output For each test case,output the answer on a single line. Sample Input 3 1 1 10 2 10000 72 Sample Output 1 6 260 Source ECJTU 2009 Spring Contest！ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,m,res;ll phi(ll x)&#123; if(x==1) return 1; ll res=x; for(ll i=2;i*i&lt;=x;i++) &#123; if(x%i==0) &#123; res-=res/i; while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res-=res/x; return res;&#125;int main()&#123; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; res=0; for(ll i=1;i*i&lt;=n;i++) &#123; if(n%i) continue; if(i&gt;=m&amp;&amp;i*i!=n) res+=phi(n/i); if(n/i&gt;=m) res+=phi(i); &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; 为什么是欧拉函数像加？因为欧拉函数可以避免乘数（循环）的时候重复。为什么i^2！=n?因为如果没有这个那么后面两个if语句会执行两次。为什么是i&gt;m？因为我们第一个循环保证了i是m的因子所以gcd(m,i)=i。满足题意。因为gcd(m,i)&gt;=n,那么gcd(m,ki)&gt;=n所以我们只要找出有多少个k倍满足就行了，但是又不能算重复，所以乘以质因子倍就不会重复了。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础]]></title>
    <url>%2F2019%2F07%2F09%2F2019-07-09-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/ojzha/article/details/79269727]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单数论推论]]></title>
    <url>%2F2019%2F07%2F08%2F2019-07-08-%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E6%8E%A8%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Leading and TrailingYou are given two integers: n and k, your task is to find the most significant three digits, and least significant three digits ofnk. Input Input starts with an integer T (≤ 1000), denoting the number of test cases. Each case starts with a line containing two integers: n (2 ≤ n &lt; 231) and k (1 ≤ k ≤ 107). Output For each case, print the case number and the three leading digits (most significant) and three trailing digits (least significant). You can assume that the input is given such that nk contains at least six digits. Sample Input 5 123456 1 123456 2 2 31 2 32 29 8751919 Sample Output Case 1: 123 456 Case 2: 152 936 Case 3: 214 648 Case 4: 429 296 Case 5: 665 669 题意是求出 n^k 的前3 个数 和 后3个数刚开始看到的时候后三个数好求，可以快速幂取余得到对于前三个数，需要利用到数学的变形首先，对于任意的一个数都可以转化成 10^x （x 为浮点数） = 10^a * 10^b (a,b 也是浮点数）的形式， *其中 10 ^ a 表示结果的位数，10^b 表示对应位的值。所以可以先求到 x 的值，再求到 b 的值，求到 10^b ,即求到了该数对应位置的值（浮点数），再乘以系数，就能得到前3位的值；* 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int Q_pow(long long x,long long m)&#123; long long ans=1; while(m) &#123; if(m&amp;1) ans=(ans*x)%1000; x=(x*x)%1000; m&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; int n; cin&gt;&gt;n; int t=1; while(n--) &#123; long long a,b; cin&gt;&gt;a&gt;&gt;b; double tmp=(double)b*log10(a*1.0); tmp=tmp-(int)tmp; double ans1=pow(10.0,tmp); int result=(int)(ans1*100.0); int ans2=Q_pow(a,b); printf(&quot;Case %d: %d %03d\n&quot;,t++,result,ans2); //cout&lt;&lt;ans1&lt;&lt;&apos; &apos;&lt;&lt;ans2&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小引理]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%BC%95%E7%90%86%2F</url>
    <content type="text"><![CDATA[本来这些东西想用一天写完的，结果脱了几天，现在决定整理一下 费马小定理 对于费马小定理，我们知道‘+’、‘-’、‘*’的取模都比较的好处理，但是遇到‘/’的取模就比较繁琐了。公式：对于gcd(a, b)=1，也就是a,b互质的情况下，若b为素数（质数），则有a^(b-1)=1(mod b)。 特别的，可以推导出：由a^(b-1)=1(mod b) 则有啊a^(b-2)=1/a(mod b)，即，a^(-1)=a^(b-2)%b欧拉函数 欧拉函数：oula(n)表示小于n的且与与n互质的数的个数oula(n)=n(1-1/p1)(1-1/p2)……(1-1/pk)，其中，pi均为小于n且与n互质的数 那么，就有欧拉的模版了：1234567891011ll oula(ll n)&#123; ll res=n; for(int i=2;i*i&lt;=n;i++) if(n%i==0) &#123; res=res/i*(i-1); while(n%i==0)n/i; &#125; return res;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哥德巴赫猜想]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[著名的哥德巴赫猜想是这样的。1.“任何一个大于二的偶数都可以分解成两个素数之和”。2.“任何一个大于5的奇数都可以分解成三个素数之和”。现在请你写两个函数验证一下这个著名的猜想。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唯一分解定理&算术基本定理]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[算术基本定理 （1）一个大于1的正整数N，如果它的标准分解式为： ，那么它的正因数个数为 。 （2） 它的全体正因数之和为 。 当 时就称N为完全数。 是否存在奇完全数，是一个至今未解决之想。 （3） 利用算术基本定理可以重新定义整数a和b的最大公因子 和最小公倍数 ， 并证明 。 （4）此外还可证明根号2是无理数等等。 （5）证明素数个数无限。 LightOJ 1341 - Aladdin and the Flying Carpet（算术基本定理 唯一分解定理）题意： 给出整数 a 和 b ，求区间[b, a] 内的 a 的约数对的个数，即：满足c*d == a 且 c&gt;=b，d&gt;=b。a 的约数对（比如[2, 3] 与 [3, 2] 为同一对）。 题解： 先素数打表，然后利用基本算术定理1求出a（面积）以内的所有正因子个数，最后/2等于对数。最后因为要所有因子要大于b所以相减就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 1000047#define LL long longLL p[maxn], prim[maxn];int k = 0;void find_prim()&#123; k = 0; for(LL i = 2; i &lt;= maxn; i++) &#123; if(!p[i]) &#123; prim[k++] = i; for(LL j = i+i; j &lt;= maxn; j+=i) &#123; p[j] = 1; &#125; &#125; &#125;&#125;LL cont(LL a)&#123; LL s = 1; if(a == 0) &#123; return 0; &#125; LL tt = 0; LL i = 0; while(prim[i] &lt; a &amp;&amp; i &lt; k) &#123; tt = 0; if(a%prim[i] == 0) &#123; while(a%prim[i] == 0) &#123; a/=prim[i]; tt++; &#125; &#125; s *= tt+1; i++; &#125; if(a &gt; 1) &#123; s *= 1+1;//一次 &#125; return s;&#125;int main()&#123; LL a, b; int t; int cas = 0; find_prim(); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); int cnt = 0; LL num = 0, ans; if(b &gt;= sqrt(a)) ans = 0; // b大小限定 else &#123; for(LL i = 1; i &lt; b; i++) //暴力枚举[1, b]中a的约数 &#123; if(a%i == 0) &#123; cnt++; &#125; &#125; num = cont(a)/2; ans = num - cnt; &#125; printf(&quot;Case %d: %lld\n&quot;,++cas,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数&欧拉筛选的应用]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%26%E6%AC%A7%E6%8B%89%E7%AD%9B%E9%80%89%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[A - Bi-shoe and Phi-shoe (欧拉函数打表) Description Bamboo Pole-vault is a massively popular sport in Xzhiland. And Master Phi-shoe is a very popular coach for his success. He needs some bamboos for his students, so he asked his assistant Bi-Shoe to go to the market and buy them. Plenty of Bamboos of all possible integer lengths (yes!) are available in the market. According to Xzhila tradition, Score of a bamboo = Φ (bamboo’s length) (Xzhilans are really fond of number theory). For your information, Φ (n) = numbers less than n which are relatively prime (having no common divisor other than 1) to n. So, score of a bamboo of length 9 is 6 as 1, 2, 4, 5, 7, 8 are relatively prime to 9. The assistant Bi-shoe has to buy one bamboo for each student. As a twist, each pole-vault student of Phi-shoe has a lucky number. Bi-shoe wants to buy bamboos such that each of them gets a bamboo with a score greater than or equal to his/her lucky number. Bi-shoe wants to minimize the total amount of money spent for buying the bamboos. One unit of bamboo costs 1 Xukha. Help him. Input Input starts with an integer T (**≤ 100)**, denoting the number of test cases. Each case starts with a line containing an integer n (1 ≤ n ≤ 10000) denoting the number of students of Phi-shoe. The next line contains n space separated integers denoting the lucky numbers for the students. Each lucky number will lie in the range [1, 106]. Output For each case, print the case number and the minimum possible money spent for buying the bamboos. See the samples for details. Sample Input 3 5 1 2 3 4 5 6 10 11 12 13 14 15 2 1 1 Sample Output Case 1: 22 Xukha Case 2: 88 Xukha Case 3: 4 Xukha 题目大意就是给定N个数，让我们找出刚好比这个大的欧拉函数值F(N)对应的那个N,最后再求和就完事了，需要注意的是，每次循环的时候应该从幸运数开始循环，不然会T 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef long long ll;#define maxN 1123456ll a[maxN];ll N;ll sum;void ola()&#123; for(int i=1;i&lt;maxN;i++) &#123; a[i]=i; &#125; for(int i=2;i&lt;maxN;i++) &#123; if(a[i]==i) &#123; for(int j=i;j&lt;maxN;j+=i) &#123; a[j]=a[j]/i*(i-1); &#125; &#125; &#125;&#125;int main()&#123; int t; ola(); cin&gt;&gt;t; int tmp=1; while(t--) &#123; int n; cin&gt;&gt;n; long long sum=0; for(int i=0;i&lt;n;i++) &#123; int temp; cin&gt;&gt;temp; for(int j=temp+1;;j++) &#123; if(a[j]&gt;=temp) &#123; sum+=j; break; &#125; &#125; &#125; //cout&lt;&lt;sum&lt;&lt;endl; printf(&quot;Case %lld: %lld Xukha\n&quot;,tmp++,sum); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除法分块模板&洛谷]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97%E6%A8%A1%E6%9D%BF%26%E6%B4%9B%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[余数求和（数学题）题目描述给出正整数n和k，计算G(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如G(10, 5)=5 mod 1 + 5 mod 2 + 5 mod 3 + 5 mod 4 + 5 mod 5 …… + 5 mod 10=0+1+2+1+0+5+5+5+5+5=29 input 10 5 output 29 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n, k; cin &gt;&gt; n &gt;&gt; k; long long ans = n * k; for(long long l = 1, r; l &lt;= n; l = r+1) &#123; if(k / l == 0)//如果小于1则直接最后一段等于右端点区间 r = n; else &#123;//不然就讨论右边端点的大小 r = min(n, k/(k/l)); &#125; ans -= (k/l)*(r-l+1)*(l+r) / 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>除法分块</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[除法分块]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-08-%E9%99%A4%E6%B3%95%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[除法分块 求以NN为被除数，在[0,N][0,N]的范围内，将所得的商向下取整相同的所有除数区间。 N∈[0,109] 做法 维护两个变量L,RL,R，代表当前除数区间为闭区间[L,R][L,R]，LL初始值为11。 然后在L≤NL≤N时循环进行下面的过程： 设t=⌊NL⌋t=⌊NL⌋ 当前答案区间的右端点R=⌊Nt⌋R=⌊Nt⌋ L=R+1 1234567891011//经典模板：long long solve(int N)&#123; int L= 1,R; long long tot = 0; while (L &lt;= N)&#123; R = N / (N / L); //求出右边的范围 tot += (N / L) * (R - L + 1); //求出商相同区间的值 L = R + 1; //区间往后移动1 &#125; return tot;&#125; 附上模板题Light OJ 1245题意：求 $$sum(n/i) i=[1,n];$$在使用除法分块后我们可以讲复杂度从n降为sqrt从而避免超时，这道题也有规律，可以枚举出来，会返现有循环节。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;long long solve(long long n)&#123; long long l=1,r; long long tot=0; while(l&lt;=n) &#123; //n/l就是这段区间的等分价; r=n/(n/l); tot+=(n/l)*(r-l+1);//等分价值乘区间总长度就是这段区间的贡献率 l=r+1; &#125; return tot;&#125;int main()&#123; int t; cin&gt;&gt;t; int cas=1; while(t--) &#123; long long m; cin&gt;&gt;m; printf(&quot;Case %d: %lld\n&quot;,cas++,solve(m)); &#125;&#125;]]></content>
      <categories>
        <category>除法分块</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因子求和&算术基本定理]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07-%E5%9B%A0%E5%AD%90%E6%B1%82%E5%92%8C%26%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Sigma Function (因子和)Sigma Function Description Sigma function is an interesting function in Number Theory. It is denoted by the Greek letter Sigma (σ). This function actually denotes the sum of all divisors of a number. For example σ(24) = 1+2+3+4+6+8+12+24=60. Sigma of small numbers is easy to find but for large numbers it is very difficult to find in a straight forward way. But mathematicians have discovered a formula to find sigma. If the prime power decomposition of an integer is Then we can write, For some n the value of σ(n) is odd and for others it is even. Given a value n, you will have to find how many integers from 1 to n have even value ofσ. Input Input starts with an integer T (≤ 100), denoting the number of test cases. Each case starts with a line containing an integer n (1 ≤ n ≤ 1012). Output For each case, print the case number and the result. Sample Input 4 3 10 100 1000 Sample Output Case 1: 1 Case 2: 5 Case 3: 83 Case 4: 947 题意：1n (n:11012)中，因子和为偶数的有几个。 先附上超时代码，根据算术基本定理写的，不了解算术基本定理的，可以查上一篇博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N=1e6+5; bool vis[N];int prime[N],cnt;void is_prime()&#123; cnt=0; memset(vis,0,sizeof(vis)); for(int i=2;i&lt;N;i++) &#123; if(!vis[i]) &#123; prime[cnt++]=i; for(int j=i+i;j&lt;N;j+=i) vis[j]=1; &#125; &#125;&#125; bool is_even(long long n)&#123; for(int i=0;i&lt;cnt&amp;&amp;prime[i]*prime[i]&lt;=n;i++) &#123; int count=0; if(n%prime[i]==0) &#123; while(n%prime[i]==0) &#123; n/=prime[i]; count++; &#125; if(prime[i]&amp;1) &#123; if(count&amp;1) return true; &#125; &#125; &#125; if(n&gt;1&amp;&amp;(n&amp;1)) return true; return false;&#125; int main()&#123; int t; cin&gt;&gt;t; is_prime(); for(int kase=1;kase&lt;=t;kase++) &#123; long long n; cin&gt;&gt;n; long long count=0; for(long long i=1;i&lt;=n;i++) &#123; if(is_even(i)) cout&lt;&lt;i&lt;&lt;endl; count++; &#125; printf(&quot;Case %d: %d\n&quot;,kase,count); &#125;&#125; 那我们该如何做这道题？ —》分析：来考虑F（x）为奇数的情况，给据题目中给我们的公式，如果F（x）为奇数，那么这个多项式里面的任何一项都必须是奇数，可以知道p = 2时， p^e - 1肯定是奇数，如果p ！= 2，当且仅当e为偶数的时候，此项为奇数，证明如下： 原式变形为[ p^(e+1) -p + (p-1) ]/ (p-1) = p*(p^e-1)/(p-1) + 1； 所以p/(p-1) = 1 ，p^e一定是奇数（因为p是质数，质数肯定是奇数）,所以p^e-1为偶数，所以下划线式肯定是奇数，证明成立。 那么题目中的公式可以写成下面的形式： 2^k0 * 3^(2k1) * 5^(2k2) * … * pn^(2*kn);下划线式可以表达为num ^ 2; 又k0&gt;=0， 所以满足条件的解为num^2和2 * num^2;因为满足2的更高次幂也一定是2的倍数，不可重复计算。代码如下： –》注意：这个题目不可以直接循环做，尽管题目中给的时间较长，但直接暴力仍然会超，这里直接计算，sqrt无法强制转换为LL，但是此题L也够了； –》感悟：数论的题目特点就是代码超短，但思维量和证明超多的那种…… 123456789101112131415161718192021#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define L longint main()&#123; int t,ca = 0; long long n; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); L ans = 0; double tmp = n; ans = L(sqrt(tmp)) + L(sqrt(tmp/2)); printf(&quot;Case %d: %ld\n&quot;,++ca,n-ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中animator 和animation区别]]></title>
    <url>%2F2019%2F06%2F27%2F2019-06-27-Unity%E4%B8%ADanimator-%E5%92%8Canimation%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Unity中animator 和animation区别此文章转载于极视学堂！！！！ ①Animation和Animator 虽然都是控制动画的播放，但是它们的用法和相关语法都是大有不同的。 Animation 控制一个动画的播放，而Animator是多个动画之间相互切换，并且Animator 有一个动画控制器，俗称动画状态机。 ②Animator 利用它做动画的切换是很方便的，但是它有一个缺点就是占用内存比Animation大。 好吧！下面直接通过操作，深入理解它们的用法。 （一） Animation模块 1.新建一个Unity3d 项目，在场景中新增一个TestAnimation对象，并且在对象上附加Animation组件； 2.选中TestAnimation对象，按快捷键：ctrl+6 打开动画编辑器，新建test.anim 动画。 3.添加AnimationPlay.cs 播放类。 using UnityEngine; using System.Collections; public class AnimationPlay : MonoBehaviour { Animation _anim; // Use this for initialization void Start () { _anim = GetComponent(); if (_anim != null) _anim.Play(“Test”); } } 4.直接运行看效果哈！ （二） Animator 模块 1.新建一个Unity3d 项目，在场景中新增一个TestAnimator对象，在Unity 编辑器中Window -&gt; Animation 弹出Animation 编辑页面，新建一个动画保存，命名为Move.anim； 同时我们发现因为使用方式是直接用动画控制器创建动画，它还会生成一个TestAnimation.controller文件，而这个文件就是我们所说的状态机控制器Controller。 2.选中需要制作动画的对象TestAnimator，例如我需要改变对象的Position，然后在Add Property 上面添加。 3.选中TestAnimation.controller这个文件，Window -&gt; Animator 打开Aniamtor 编辑器。 4.需要增加一个largen.anim动画，可以让它们互相切换。 5.直接运行看效果。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的一些鼠标事件]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26-Unity%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Unity中的一些鼠标事件 由于项目需求，需要使用鼠标点击来实现滑动事件，查看官方文档对Input.GetMouseButton部分进行了了解。 GetMouseButton:每一帧鼠标处于按下状态都会返回true,Input.GetMouseButton(0):表示鼠标左键按下，Input.GetMouseButton(1):表示鼠标右键按下，Input.GetMouseButton(2):表示鼠标中键按下 GetMouseButtonDown:鼠标按下的那一帧返回true,Input.GetMouseButtonDown(0):表示鼠标左键按下，Input.GetMouseButtonDown(1):表示鼠标右键按下，Input.GetMouseButtonDown(2):表示鼠标中键按下 GetMouseButtonUp:鼠标抬起的那一帧返回true,Input.GetMouseButtonUp(0):表示鼠标左键按下，Input.GetMouseButtonUp(1):表示鼠标右键按下，Input.GetMouseButtonUp(2):表示鼠标中键按下 鼠标按下和抬起的位置可以通过Input.mousePosition来获取，不过该参数返回的是屏幕坐标位置，即以左下角为原点的坐标系。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity常用函数和变量汇总]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26-Unity%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1，代码。 1234567891011121314151617float3 WorldSpaceViewDir(float4 v) //输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向 float3 ObjSpaceViewDir(float4 v) //输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向 float3 WorldSpaceLightDir(float4 v) //仅用于前向渲染中（ForwardBase）,输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有被归一化 float3 UnityWorldSpaceLightDir(float4 v) //仅可用于前向渲染中，输入一个世界空间的顶点位置，返回世界空间从该点到光源的光照方向，没有被归一化 float3 ObjSpaceLightDir(float4 v) //仅用于前向渲染中（ForwardBase）,输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向，没有被归一化 float3 UnityObjectToWorldNormal(float3 norm) //把法线从模型空间转换到世界空间中 float3 UnityObjectToWorldDir(in float3 dir) //把方向矢量从模型空间转换到世界空间中 float3 UnityWorldToObjectDir(float3 dir) //把方向矢量从世界空间转换到模型空间中 float3 Shade4PointLights(...) //仅可用于前向渲染中，计算四个点光源的光照，它的参数是已经打包进矢量的光照数据。前向渲染通常会使用这个函数来计算逐顶点光照 2，语义。1234567891011121314151617181920POSITION //模型空间中的顶点位置，通常是float4类型 NORMAL //顶点法线，通常是float3类型 TANGENT //顶点法线，通常是float4类型 TEXCOORDn //该顶点的纹理坐标，TEXCOORD0表示第一组纹理坐标，…,通常是float2或float4类型 COLOR //顶点颜色，通常是fixed4或float4类型 SV_POSITION //裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于DirectX9中的POSITION，但是最好是使用SV_POSITION COLOR0 //输出第一组顶点颜色 COLOR1 //输出第二组顶点颜色 TEXCOORD0~TEXCOORD7 //输出纹理坐标 SV_Target //输出值将会存储到渲染目标（render target）中 3，变量。1234567891011121314151617UNITY_MATRIX_MVP //当前的模型*观察*投影矩阵，用于将顶点/方向矢量从模型空间转换到裁剪空间 UNITY_MATRIX_MV //当前的模型*观察矩阵，用于将顶点/方向矢量从模型空间转换到观察空间 UNITY_MATRIX_V //当前的观察矩阵，用于将顶点/方向矢量从世界空间转换到观察空间 UNITY_MATRIX_P //当前的投影矩阵，用于将顶点/方向矢量从观察空间转换到裁剪空间 UNITY_MATRIX_VP //当前的观察*投影矩阵，用于将顶点/方向矢量从世界空间转换到裁剪空间 UNITY_MATRIX_T_MV //UNITY_MATRIX_MV的转置矩阵 UNITY_MATRIX_IT_MV //UNITY_MATRIX_MV的逆转置矩阵，用于将发现从模型空间转换到观察空间，也可以用于得到UNITY_MATRIX_MV的逆矩阵 unity_ObjectToWorld(_Object2World) //当前的模型矩阵，用于将顶点/方向矢量从模型空间变换到世界空间 unity_WorldToObject(_World2Object) //用于将顶点/方向矢量从世界空间转换到模型空间 4，摄像机和屏幕参数。123456789101112131415float3 _WorldSpaceCameraPos //该摄像机在世界空间中的位置 float4 _ProjectionParams //x=1.0(或-1.0，如果正在使用一个翻转的投影矩阵进行渲染)，y=Near,z=Far,w=1.0+1.0/Far,其中Near和Far分别是近裁剪平面和远裁剪平面到摄像机的距离 float4 _ScreenParams //x=width,y=height,z=1.0+1.0/width,w=1.0+1.0/height,其中width和height分别是该摄像机的渲染目标（render target）的像素宽度和高度 float4 _ZBufferParams //x=1-Far/Near,y=Far/Near,z=x/Far,w=y/Far,该变量用于线性化Z缓存中的深度值 float4 unity_OrthoParams //x=width,y=height,z没有定义,w=1.0(该摄像机是正交摄像机)或w=0.0（该摄像机是透视摄像机），其中width和height是正交投影摄像机的宽度和高度 float4x4 unity_CameraProjection //该摄像机的投影矩阵 float4x4 unity_CameraInvProjection //该摄像机的投影矩阵的逆矩阵 float4 unity_CameraWorldClipPlanes[6] //该摄像机的6个裁剪平面在世界空间下的等式，按左、右、下、上、近、远裁剪平面 5,内置的光照变量。1234567891011_LightColor0 float4 //该Pass处理的逐像素光源的颜色 _WorldSpaceLightPos0 float4 //_WorldSpaceLightPos0.xyz是该Pass处理的逐像素光源的位置。如果该光源是平行光，那么_WorldSpaceLightPos0.w是0，其他光源类型是1 _LightMatrix0 float4x4 //从世界空间到光源空间的变换矩阵，可以用于采样cookie和光强衰减纹理 unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0 float4 //仅用于Base Pass,前4个非重要的点光源在世界空间中的位置 unity_4LightAtten() float4 //仅用于Base Pass， 存储了前4个非重要的点光源的衰减因子 unity_LightColor half4[4] //仅用于Base Pass，存储了前4个非重要的点光源的颜色 6，LightMode标签支持的渲染路径设置选项。12345678Always //不管使用哪种渲染路径，该Pass总会被渲染，但是不会计算任何光照ForwardBase //用于前向渲染，该Pass会计算环境光，最重要的的平行光，逐顶点/SH光源和LightmapsForwardAdd //用于前向渲染，该Pass会计算额外的逐像素光源，每个Pass对应一个光源Deferred //用于延迟渲染，该Pass会渲染G缓冲（G_buffer）ShadowCaster //把物体的深度信息渲染到阴影映射纹理或一张深度纹理中PrepassBase //用于遗留延迟渲染，该Pass会渲染法线和高光反射的指数部分PrepassFinal //用于遗留延迟渲染，该Pass通过合并纹理、光照、自发光来渲染得到的最后的颜色Vertex,VertexLMRGBM和VertexLM //用于遗留的顶点照明渲染 7，顶点照明渲染路径中可以使用的内置变量。1234567unity_LightColor half4[8] //光源颜色 unity_LightPosition float4[8] //xyz分量是视角空间中的光源位置，如果光源是平行光，那么z分量值为0，其他光源类型z分量值为1 unity_LightAtten half4[8] //光源衰减因子，如果光源是聚光灯，x分量是cos(spotAngle/2),y分量是1/cos(spotAngle/4);如果是其他光源，x分量是-1，y分量是1，z分量是衰减的平分，w分量是光源范围开根号的结果 unity_SpotDirection float4[8] //如果光源是聚光灯的话，值为视角空间的聚光灯的位置，如果是其他类型的光源，值为（0,0,1,0） 8，顶点照明渲染路径中可以使用的内置函数。123float3 ShadeVertexLights(float4 vertex,float normal) //输入模型空间中的顶点位置和法线，计算四个顶点光源的光照以及环境光 float3 ShadeVertexLightsFull(float4 vertex, float3 normal, int lightCount, bool spotLight) //输入模型空间中的顶点位置和法线，计算lightCount个光源的光照以及环境光，如果SpotLight值为true，那么这些光源会被当成聚光灯来处理，虽然结果更精确，但计算更加耗时，否则，按点光源处理]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3d中awake和start函数的理解。]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26-unity3d%E4%B8%ADawake%E5%92%8Cstart%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%2F</url>
    <content type="text"><![CDATA[unity3d中awake和start函数的理解。1、 Awake函数 ​ 首先，我们来看unity的参考手册中对Awake函数的一些说明情况： ​ 当脚本实例被加载时会调用Awake函数；Awake函数在所有的游戏对象被初始化完毕之后才会被调用；在脚本实例的整个生命周期中，Awake函数仅执行一次。那么，脚本实例何时被加载，脚本实例的整个生命周期又代表了什么，因为对这些概念存有疑惑，所以在此基础之上，自己又在引擎中进行了一些测试，通过打印输出的方式查看了一下Awake函数的执行情况，总结如下（没有特殊说明，均为在不切换场景的前提下）： ​ （1） 如果游戏对象（即gameObject）的初始状态为关闭状态，那么运行程序，Awake函数不会执行；反之，如果游戏对象的初始状态为开启状态，那么Awake函数会执行。并且，值得注意的一点是，Awake函数的执行与否与脚本实例的状态（启用或禁用）并没有关系，而是与脚本实例所绑定的游戏对象的状态有关。 ​ （2） 在不切换场景的前提下，原本处于关闭状态的游戏对象，当它被首次开启时，Awake函数会执行，并且是只在首次开启时才会执行；而已经开启（激活）的游戏对象（Awake函数已经执行过一次），将它关闭后再次开启，Awake函数不会再次执行。看来这是对应了手册中说明的在脚本实例的整个生命周期中仅执行一次的情况。 ​ （3） 如果重新加载场景，那么场景内Awake函数的执行情况重新遵循上述两点。 2、 Start函数 ​ 还是先看参考手册中对Start函数的一些说明情况： ​ 当Update函数第一次被调用前会调用Start函数；Start函数只在脚本实例被启用时才会执行；Start函数总是在Awake函数之后执行。在此基础之上，自己的测试总结如下 （没有特殊说明，均为在不切换场景的前提下）： ​ （1） 如果游戏对象被关闭，那么Start函数不会执行。想一想这是理所当然的，游戏对象关闭了，脚本实例不会被加载，Awake函数不会执行，Start函数不会执行，Update函数等也不会执行。 ​ （2） 如果游戏对象开启了，对象上绑定的脚本实例被禁用了，那么Start函数不会执行。这是Start函数的特点，只有在脚本实例被启用时它才会执行，这个说明中有提到。注意，这与Awake函数是有区别的。 ​ （3） 如果游戏对象开启了，对象上绑定的脚本实例也开启了，那么Start函数会执行。并且Start函数只会在脚本实例首次被开启时才会执行。如果是已经开启过的脚本实例被关闭后再次开启，那么Start函数不会再次执行。 ​ （4） 如果重新加载场景，那么场景内Start函数的执行情况重新遵循上述三点。 ​ 除此之外，还有对Awake函数和Start函数都比较重要的一点，那就是当游戏对象之间存在父子关系时（不论层级的多少）。这时，父游戏对象的状态（开启或关闭）完全决定了子游戏对象上的脚本函数的执行情况。总的来说就是，只有在父游戏对象被开启的状态下，程序才会考虑是否调用子游戏对象上的脚本函数（Awake与Start等）。自上而下，以此类推。 ​ 最后，自己对于Awake与Start函数的使用，一般都是在Awake函数中获取游戏对象或者脚本实例的信息，然后在Start函数中进行一些获取之后的初始化设置。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1757 A Simple Math Problem（矩阵快速幂）]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26-HDU-1757-A-Simple-Math-Problem%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Problem DescriptionLele now is thinking about a simple function f(x). If x &lt; 10 f(x) = x.If x &gt;= 10 f(x) = a0 * f(x-1) + a1 * f(x-2) + a2 * f(x-3) + …… + a9 * f(x-10);And ai(0&lt;=i&lt;=9) can only be 0 or 1 . Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m. InputThe problem contains mutiple test cases.Please process to the end of file.In each case, there will be two lines.In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )In the second line , there are ten integers represent a0 ~ a9. OutputFor each case, output f(k) % m in one line. Sample Input10 9999 1 1 1 1 1 1 1 1 1 1 20 500 1 0 1 0 1 0 1 0 1 0 Sample Output45 第一次做矩阵快速幂的题，在矩阵快速幂中，我觉得重要的三个 初始化矩阵就是单位矩阵，初始化矩阵，系数矩阵。考这三个矩阵以及递推式来可以从f(1)推出任意f(n) 题目关键是要构造关系矩阵。f(x) a0 a1 a2 a3 a4 … a9 f(x-1) f(x-1) 1 0 0 0 … 0 f(x-2) f(x-2) = 0 1 0 0 * f(x-3) .. 0 0 1 0 .. f(x-9) 0 0 0 … 1 f(x-10) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;typedef long long ll;ll k, mod;struct Maxtri&#123; int a[15][15];&#125;;Maxtri unit, init;void Creat_Maxtri() &#123;//构造矩阵 memset(init.a, 0, sizeof(init.a)); for(int i = 1; i &lt; 10; i++) &#123; init.a[i][i-1] = 1; &#125; memset(unit.a, 0, sizeof(unit.a)); for(int i = 0; i &lt; 10; i++) &#123; unit.a[i][i] = 1; &#125;&#125;Maxtri Multi(Maxtri a, Maxtri b) &#123;//矩阵相乘 Maxtri c; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; c.a[i][j] = 0; for(int k = 0; k &lt; 10; k++) &#123; c.a[i][j] += (a.a[i][k] * b.a[k][j]) % mod; c.a[i][j] %= mod; &#125; &#125; &#125; return c;&#125;Maxtri Fast_Pow(Maxtri a, Maxtri b, int x) &#123; //快速乘 while(x) &#123; if(x&amp;1) &#123; b = Multi(a, b); &#125; a = Multi(a, a); x &gt;&gt;= 1; &#125; return b;&#125;int main() &#123; while(scanf(&quot;%lld %lld&quot;, &amp;k, &amp;mod) != EOF) &#123; Creat_Maxtri(); for(int i = 0; i &lt; 10; i++) &#123; scanf(&quot;%d&quot;, &amp;init.a[0][i]); &#125; if(k &lt; 10) &#123; printf(&quot;%d\n&quot;, k%mod); continue; &#125; Maxtri res = Fast_Pow(init, unit, k-9); ll ans = 0; for(int i = 0; i &lt; 10; i++) &#123; ans += (res.a[0][i] * (9-i))%mod; &#125; printf(&quot;%lld\n&quot;, ans%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity如何导入资源]]></title>
    <url>%2F2019%2F06%2F23%2FUnity%E5%A6%82%E4%BD%95%E5%AF%BC%E5%85%A5%E8%B5%84%E6%BA%90%E3%80%82%2F</url>
    <content type="text"><![CDATA[Unity如何导入资源。要用自己的素材，可以把素材装在一个文件夹里然后放在Assets的文件夹下面噢，再来unity里读取。 就是这个东西啦，右键Assets，选择Import Package 。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ropewalkers]]></title>
    <url>%2F2019%2F06%2F21%2FRopewalkers%2F</url>
    <content type="text"><![CDATA[RopewalkersPolycarp decided to relax on his weekend and visited to the performance of famous ropewalkers: Agafon, Boniface and Konrad. The rope is straight and infinite in both directions. At the beginning of the performance, Agafon, Boniface and Konrad are located in positions aa, bb and cc respectively. At the end of the performance, the distance between each pair of ropewalkers was at least dd. Ropewalkers can walk on the rope. In one second, only one ropewalker can change his position. Every ropewalker can change his position exactly by 11 (i. e. shift by 11 to the left or right direction on the rope). Agafon, Boniface and Konrad can not move at the same time (Only one of them can move at each moment). Ropewalkers can be at the same positions at the same time and can “walk past each other”. You should find the minimum duration (in seconds) of the performance. In other words, find the minimum number of seconds needed so that the distance between each pair of ropewalkers can be greater or equal to dd. Ropewalkers can walk to negative coordinates, due to the rope is infinite to both sides. Input The only line of the input contains four integers aa, bb, cc, dd (1≤a,b,c,d≤1091≤a,b,c,d≤109). It is possible that any two (or all three) ropewalkers are in the same position at the beginning of the performance. Output Output one integer — the minimum duration (in seconds) of the performance. `` 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main()&#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int x[]=&#123;a,b,c&#125;; sort(x,x+3); cout&lt;&lt;max(0,d-abs(x[0]-x[1]))+max(0,d-abs(x[1]-x[2]))&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Email from Polycarp]]></title>
    <url>%2F2019%2F06%2F21%2FEmail%20from%20Polycarp%2F</url>
    <content type="text"><![CDATA[Email from PolycarpMethodius received an email from his friend Polycarp. However, Polycarp’s keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol). For example, as a result of typing the word “hello”, the following words could be printed: “hello”, “hhhhello”, “hheeeellllooo”, but the following could not be printed: “hell”, “helo”, “hhllllooo”. Note, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result. For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him. You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp’s keyboard. Input The first line of the input contains one integer nn (1≤n≤1051≤n≤105) — the number of pairs to check. Further input contains nn descriptions of pairs. The first line of each description contains a single non-empty word ss consisting of lowercase Latin letters. The second line of the description contains a single non-empty word tt consisting of lowercase Latin letters. The lengths of both strings are not greater than 106106. It is guaranteed that the total length of all words ss in the input is not greater than 106106. Also, it is guaranteed that the total length of all words tt in the input is not greater than 106106. Output Output nn lines. In the ii-th line for the ii-th pair of words ss and tt print YES if the word tt could be printed by typing the word ss. Otherwise, print NO. 思路：主串中出现字母的顺序必须在父串中按照相同顺序出现，并且出现的次数必须大于等于父串中字母出现的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1e6 +50;string a,b;int Next[maxn];int m,n;bool su;void fun(string a,string b)&#123; int i=0,j=0; int ii=0,jj=0; while(i&lt;a.size()&amp;&amp;j&lt;b.size()) &#123; ii=i; jj=j; while(ii&lt;a.size()&amp;&amp;a[i]==a[ii])ii++; while(jj&lt;b.size()&amp;&amp;b[j]==b[jj])jj++; if(a[i]!=b[j])su=0; if(abs(ii-i)&gt;abs(jj-j))su=0; i=ii; j=jj; &#125; if(i!=a.size()||j!=b.size()) su=0;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; su=1; cin&gt;&gt;a&gt;&gt;b; fun(a,b); if(su==1) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125;`]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Email from Polycarp]]></title>
    <url>%2F2019%2F06%2F21%2FExam%20in%20BerSU%20(easy%20version)%2F</url>
    <content type="text"><![CDATA[Exam in BerSU (easy version)The only difference between easy and hard versions is constraints. A session has begun at Beland State University. Many students are taking exams. Polygraph Poligrafovich is going to examine a group of nn students. Students will take the exam one-by-one in order from 11-th to nn-th. Rules of the exam are following: The ii-th student randomly chooses a ticket. if this ticket is too hard to the student, he doesn’t answer and goes home immediately (this process is so fast that it’s considered no time elapses). This student fails the exam. if the student finds the ticket easy, he spends exactly titi minutes to pass the exam. After it, he immediately gets a mark and goes home. Students take the exam in the fixed order, one-by-one, without any interruption. At any moment of time, Polygraph Poligrafovich takes the answer from one student. The duration of the whole exam for all students is MM minutes (maxti≤Mmaxti≤M), so students at the end of the list have a greater possibility to run out of time to pass the exam. For each student ii, you should count the minimum possible number of students who need to fail the exam so the ii-th student has enough time to pass the exam. For each student ii, find the answer independently. That is, if when finding the answer for the student i1i1 some student jj should leave, then while finding the answer for i2i2 (i2&gt;i1i2&gt;i1) the student jj student does not have to go home. Input The first line of the input contains two integers nn and MM (1≤n≤1001≤n≤100, 1≤M≤1001≤M≤100) — the number of students and the total duration of the exam in minutes, respectively. The second line of the input contains nn integers titi (1≤ti≤1001≤ti≤100) — time in minutes that ii-th student spends to answer to a ticket. It’s guaranteed that all values of titi are not greater than MM. Output Print nn numbers: the ii-th number must be equal to the minimum number of students who have to leave the exam in order to ii-th student has enough time to pass the exam. 思路题目中要求剪掉的数目最少，即每次减少人腾出的时间更多，并且ti&lt;=100，所以我们很容易想到从大到小的进行贪心。然后后每次利用桶来进行每个时间对应的人数的维护就好了。 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+7;int n,m,a[N],s[N],num[102];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); s[i]=s[i-1]+a[i]; &#125; for(int i=1;i&lt;=n;i++) if(s[i]&lt;=m)printf(&quot;0 &quot;),num[a[i]]++; else&#123; int rest=s[i]-m,ans=0; for(int j=100;j;j--) &#123; if(j*num[j]&lt;rest) rest-=j*num[j],ans+=num[j]; else&#123;ans+=(rest+j-1)/j;break;&#125; //这一步理解有点困难，其实小伙伴可以画一条数轴就明白了。 printf(&quot;%d &quot;,ans); num[a[i]]++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[起点]]></title>
    <url>%2F2019%2F06%2F17%2FACM%E6%AD%A3%E5%BC%8F%E5%90%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ACM正式启程经过大一的ACM淘汰赛后终于正式留下来了，由小白变成入门一路过来很不容易，感谢大一 一学年学长的栽培，马上要迎来大学的第一个暑假，杭电集训如期而至，海量的算法，希望在今后剩余的ACM生涯里可以和我的两位队友摘得区域赛金牌，打破计科无金的历史。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>

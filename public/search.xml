<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ropewalkers]]></title>
    <url>%2F2019%2F06%2F21%2FRopewalkers%2F</url>
    <content type="text"><![CDATA[RopewalkersPolycarp decided to relax on his weekend and visited to the performance of famous ropewalkers: Agafon, Boniface and Konrad. The rope is straight and infinite in both directions. At the beginning of the performance, Agafon, Boniface and Konrad are located in positions aa, bb and cc respectively. At the end of the performance, the distance between each pair of ropewalkers was at least dd. Ropewalkers can walk on the rope. In one second, only one ropewalker can change his position. Every ropewalker can change his position exactly by 11 (i. e. shift by 11 to the left or right direction on the rope). Agafon, Boniface and Konrad can not move at the same time (Only one of them can move at each moment). Ropewalkers can be at the same positions at the same time and can “walk past each other”. You should find the minimum duration (in seconds) of the performance. In other words, find the minimum number of seconds needed so that the distance between each pair of ropewalkers can be greater or equal to dd. Ropewalkers can walk to negative coordinates, due to the rope is infinite to both sides. Input The only line of the input contains four integers aa, bb, cc, dd (1≤a,b,c,d≤1091≤a,b,c,d≤109). It is possible that any two (or all three) ropewalkers are in the same position at the beginning of the performance. Output Output one integer — the minimum duration (in seconds) of the performance. `` 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main()&#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int x[]=&#123;a,b,c&#125;; sort(x,x+3); cout&lt;&lt;max(0,d-abs(x[0]-x[1]))+max(0,d-abs(x[1]-x[2]))&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Email from Polycarp]]></title>
    <url>%2F2019%2F06%2F21%2FEmail%20from%20Polycarp%2F</url>
    <content type="text"><![CDATA[Email from PolycarpMethodius received an email from his friend Polycarp. However, Polycarp’s keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol). For example, as a result of typing the word “hello”, the following words could be printed: “hello”, “hhhhello”, “hheeeellllooo”, but the following could not be printed: “hell”, “helo”, “hhllllooo”. Note, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result. For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him. You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp’s keyboard. Input The first line of the input contains one integer nn (1≤n≤1051≤n≤105) — the number of pairs to check. Further input contains nn descriptions of pairs. The first line of each description contains a single non-empty word ss consisting of lowercase Latin letters. The second line of the description contains a single non-empty word tt consisting of lowercase Latin letters. The lengths of both strings are not greater than 106106. It is guaranteed that the total length of all words ss in the input is not greater than 106106. Also, it is guaranteed that the total length of all words tt in the input is not greater than 106106. Output Output nn lines. In the ii-th line for the ii-th pair of words ss and tt print YES if the word tt could be printed by typing the word ss. Otherwise, print NO. 思路：主串中出现字母的顺序必须在父串中按照相同顺序出现，并且出现的次数必须大于等于父串中字母出现的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn = 1e6 +50;string a,b;int Next[maxn];int m,n;bool su;void fun(string a,string b)&#123; int i=0,j=0; int ii=0,jj=0; while(i&lt;a.size()&amp;&amp;j&lt;b.size()) &#123; ii=i; jj=j; while(ii&lt;a.size()&amp;&amp;a[i]==a[ii])ii++; while(jj&lt;b.size()&amp;&amp;b[j]==b[jj])jj++; if(a[i]!=b[j])su=0; if(abs(ii-i)&gt;abs(jj-j))su=0; i=ii; j=jj; &#125; if(i!=a.size()||j!=b.size()) su=0;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; su=1; cin&gt;&gt;a&gt;&gt;b; fun(a,b); if(su==1) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125;`]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Email from Polycarp]]></title>
    <url>%2F2019%2F06%2F21%2FExam%20in%20BerSU%20(easy%20version)%2F</url>
    <content type="text"><![CDATA[Exam in BerSU (easy version)The only difference between easy and hard versions is constraints. A session has begun at Beland State University. Many students are taking exams. Polygraph Poligrafovich is going to examine a group of nn students. Students will take the exam one-by-one in order from 11-th to nn-th. Rules of the exam are following: The ii-th student randomly chooses a ticket. if this ticket is too hard to the student, he doesn’t answer and goes home immediately (this process is so fast that it’s considered no time elapses). This student fails the exam. if the student finds the ticket easy, he spends exactly titi minutes to pass the exam. After it, he immediately gets a mark and goes home. Students take the exam in the fixed order, one-by-one, without any interruption. At any moment of time, Polygraph Poligrafovich takes the answer from one student. The duration of the whole exam for all students is MM minutes (maxti≤Mmaxti≤M), so students at the end of the list have a greater possibility to run out of time to pass the exam. For each student ii, you should count the minimum possible number of students who need to fail the exam so the ii-th student has enough time to pass the exam. For each student ii, find the answer independently. That is, if when finding the answer for the student i1i1 some student jj should leave, then while finding the answer for i2i2 (i2&gt;i1i2&gt;i1) the student jj student does not have to go home. Input The first line of the input contains two integers nn and MM (1≤n≤1001≤n≤100, 1≤M≤1001≤M≤100) — the number of students and the total duration of the exam in minutes, respectively. The second line of the input contains nn integers titi (1≤ti≤1001≤ti≤100) — time in minutes that ii-th student spends to answer to a ticket. It’s guaranteed that all values of titi are not greater than MM. Output Print nn numbers: the ii-th number must be equal to the minimum number of students who have to leave the exam in order to ii-th student has enough time to pass the exam. 思路题目中要求剪掉的数目最少，即每次减少人腾出的时间更多，并且ti&lt;=100，所以我们很容易想到从大到小的进行贪心。然后后每次利用桶来进行每个时间对应的人数的维护就好了。 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+7;int n,m,a[N],s[N],num[102];int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); s[i]=s[i-1]+a[i]; &#125; for(int i=1;i&lt;=n;i++) if(s[i]&lt;=m)printf(&quot;0 &quot;),num[a[i]]++; else&#123; int rest=s[i]-m,ans=0; for(int j=100;j;j--) &#123; if(j*num[j]&lt;rest) rest-=j*num[j],ans+=num[j]; else&#123;ans+=(rest+j-1)/j;break;&#125; //这一步理解有点困难，其实小伙伴可以画一条数轴就明白了。 printf(&quot;%d &quot;,ans); num[a[i]]++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[起点]]></title>
    <url>%2F2019%2F06%2F17%2FACM%E6%AD%A3%E5%BC%8F%E5%90%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ACM正式启程经过大一的ACM淘汰赛后终于正式留下来了，由小白变成入门一路过来很不容易，感谢大一 一学年学长的栽培，马上要迎来大学的第一个暑假，杭电集训如期而至，海量的算法，希望在今后剩余的ACM生涯里可以和我的两位队友摘得区域赛金牌，打破计科无金的历史。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
